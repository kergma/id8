/*
https://github.com/kergma/id8
version 3
44 bits for time, 14 bits for a sequence, 6 bits for a generator number
time resolution: 10ms (1/100 of a second)
time range: from 1970-01-01T00:00:00+00 to 4757-05-16T07:43:42+00
generation speed limit: 1,634,800 ids per second
possible generators : 64, numbered from 0 to 63
*/

-- A generator number: identifiers generated by different generators can be safely merged without risk of duplication
create or replace function id8generator() returns int as
$$
	select 11
$$
language sql immutable;

create sequence id_helper minvalue 0 maxvalue 16383 cycle;

create or replace function generate_id() returns int8 as
$$
	select ((100*extract(epoch from clock_timestamp()))::int8::bit(44)||case nextval('id_helper') when 16383 then case when pg_sleep(0.01) is null then 1 else 16383 end else currval('id_helper') end::bit(14)||id8generator()::bit(6))::bit(64)::int8;
$$
language sql volatile;

create or replace function generate_id(at_time timestamp with time zone) returns int8 as
$$
	select ((100*extract(epoch from at_time))::int8::bit(44)||nextval('id_helper')::bit(14)||id8generator()::bit(6))::bit(64)::int8;
$$
language sql volatile;
comment on function generate_id(timestamp with time zone) is 'Attention: for each moment of time there are only 16384 unique ids can be generated';

create or replace function id_of_timestamp(t timestamp with time zone) returns int8 as
$$
	select ((100*extract(epoch from t))::int8::bit(44)||'00000000000000000000')::bit(64)::int8;
$$
language sql immutable;

create or replace function timestamp_of_id(i int8) returns timestamp with time zone as
$$
	select timestamp with time zone 'epoch' + substring(i::bit(64) from 1 for 44)::int8::double precision/100*interval '1 second';
$$
language sql immutable;

create or replace function generator_of_id(i int8) returns int as
$$
	select substring(i::bit(64) from 59 for 6)::int;
$$
language sql immutable;

create or replace function isid(v anyelement)
returns boolean language sql immutable
as $_$
	select v::text ~ '^\d+$';
$_$;

create or replace function id8speed(minduration int default 7) returns int as
$$
declare
	start_time float;
	duration float=0;
	speed int=0;
	iteration int=0;
	number int=1024;
begin
	loop
		iteration=iteration+1;
		create table pg_temp.id8test(id int8);
		start_time=extract(epoch from clock_timestamp());
		insert into pg_temp.id8test (id) select generate_id() from generate_series(1,number);
		duration=extract(epoch from clock_timestamp())-start_time;
		if duration=0 then speed=null; else speed=round(number/duration); end if;
		raise notice 'iteration %, number %, duration %, speed % ids per second',iteration,number,duration,speed;
		drop table pg_temp.id8test;
		number=number*2;
		if duration>=minduration then exit; end if;
		if duration>60 then exit; end if;
		if iteration>=30 then exit; end if;
	end loop;
	return speed;
end
$$ language plpgsql;
